{"ast":null,"code":"// API utility for backend communication\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n/**\n * Create a new audio session\n * @returns {Promise<{session_id: string}>}\n */\nexport async function createSession() {\n  const response = await fetch(`${API_BASE_URL}/api/session`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to create session: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Start calibration for a session\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function startCalibration(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/start`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to start calibration: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Finish calibration for a session\n * @param {string} sessionId\n * @returns {Promise<{baseline: number, duration: number, text: string}>}\n */\nexport async function finishCalibration(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/finish`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to finish calibration: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Get calibration status for a session\n * @param {string} sessionId\n * @returns {Promise<{calibration_baseline: number|null, calibration_duration: number|null, warning_active: boolean}>}\n */\nexport async function getCalibrationStatus(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/status`, {\n    method: 'GET'\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to get calibration status: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Dismiss warning for a session\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function dismissWarning(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/dismiss-warning`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to dismiss warning: ${response.statusText}`);\n  }\n  return response.json();\n}\nlet sharedAudioContext = null;\nasync function getAudioContext() {\n  if (typeof window === 'undefined') {\n    throw new Error('AudioContext is not available in this environment.');\n  }\n  if (!sharedAudioContext) {\n    const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContextClass) {\n      throw new Error('AudioContext API não suportada neste navegador.');\n    }\n    sharedAudioContext = new AudioContextClass();\n  }\n  if (sharedAudioContext.state === 'suspended') {\n    await sharedAudioContext.resume();\n  }\n  return sharedAudioContext;\n}\nfunction floatTo16BitPCM(float32Array) {\n  const buffer = new ArrayBuffer(float32Array.length * 2);\n  const view = new DataView(buffer);\n  let offset = 0;\n  for (let i = 0; i < float32Array.length; i++, offset += 2) {\n    let s = Math.max(-1, Math.min(1, float32Array[i]));\n    s = s < 0 ? s * 0x8000 : s * 0x7fff;\n    view.setInt16(offset, s, true);\n  }\n  return buffer;\n}\nfunction arrayBufferToBase64(buffer) {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  const chunkSize = 0x8000;\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize);\n    binary += String.fromCharCode.apply(null, chunk);\n  }\n  return btoa(binary);\n}\nasync function blobToPcmPayload(audioBlob) {\n  const arrayBuffer = await audioBlob.arrayBuffer();\n  const audioContext = await getAudioContext();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));\n  const channelData = audioBuffer.getChannelData(0);\n  const pcmBuffer = floatTo16BitPCM(channelData);\n  const samplesBase64 = arrayBufferToBase64(pcmBuffer);\n  return {\n    samples: samplesBase64,\n    sampleRate: audioBuffer.sampleRate\n  };\n}\n\n/**\n * Send audio chunk to backend for processing\n * @param {string} sessionId\n * @param {Blob} audioBlob\n * @returns {Promise<{warning_active: boolean, transcript: object|null}>}\n */\nexport async function sendAudioChunk(sessionId, audioBlob) {\n  const {\n    samples,\n    sampleRate\n  } = await blobToPcmPayload(audioBlob);\n  const response = await fetch(`${API_BASE_URL}/api/audio-chunk`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      session_id: sessionId,\n      sample_rate: sampleRate,\n      samples\n    })\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to send audio chunk: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Start listening (for monitoring mode)\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function startListening(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/start-listening/${sessionId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to start listening: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Stop listening (for monitoring mode)\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function stopListening(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/stop-listening/${sessionId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to stop listening: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n/**\n * Get session status\n * @param {string} sessionId\n * @returns {Promise<{state: string, transcripts: array}>}\n */\nexport async function getSessionStatus(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/session/${sessionId}/status`, {\n    method: 'GET'\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to get session status: ${response.statusText}`);\n  }\n  return response.json();\n}","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","createSession","response","fetch","method","headers","ok","Error","statusText","json","startCalibration","sessionId","finishCalibration","getCalibrationStatus","dismissWarning","sharedAudioContext","getAudioContext","window","AudioContextClass","AudioContext","webkitAudioContext","state","resume","floatTo16BitPCM","float32Array","buffer","ArrayBuffer","length","view","DataView","offset","i","s","Math","max","min","setInt16","arrayBufferToBase64","bytes","Uint8Array","binary","chunkSize","chunk","subarray","String","fromCharCode","apply","btoa","blobToPcmPayload","audioBlob","arrayBuffer","audioContext","audioBuffer","decodeAudioData","slice","channelData","getChannelData","pcmBuffer","samplesBase64","samples","sampleRate","sendAudioChunk","body","JSON","stringify","session_id","sample_rate","startListening","stopListening","getSessionStatus"],"sources":["/home/hugorteixeira/AvisoVC/frontend/src/utils/api.js"],"sourcesContent":["// API utility for backend communication\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n/**\n * Create a new audio session\n * @returns {Promise<{session_id: string}>}\n */\nexport async function createSession() {\n  const response = await fetch(`${API_BASE_URL}/api/session`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to create session: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Start calibration for a session\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function startCalibration(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/start`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to start calibration: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Finish calibration for a session\n * @param {string} sessionId\n * @returns {Promise<{baseline: number, duration: number, text: string}>}\n */\nexport async function finishCalibration(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/finish`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to finish calibration: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Get calibration status for a session\n * @param {string} sessionId\n * @returns {Promise<{calibration_baseline: number|null, calibration_duration: number|null, warning_active: boolean}>}\n */\nexport async function getCalibrationStatus(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/status`, {\n    method: 'GET',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to get calibration status: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Dismiss warning for a session\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function dismissWarning(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/calibration/${sessionId}/dismiss-warning`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to dismiss warning: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\nlet sharedAudioContext = null;\n\nasync function getAudioContext() {\n  if (typeof window === 'undefined') {\n    throw new Error('AudioContext is not available in this environment.');\n  }\n  if (!sharedAudioContext) {\n    const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContextClass) {\n      throw new Error('AudioContext API não suportada neste navegador.');\n    }\n    sharedAudioContext = new AudioContextClass();\n  }\n  if (sharedAudioContext.state === 'suspended') {\n    await sharedAudioContext.resume();\n  }\n  return sharedAudioContext;\n}\n\nfunction floatTo16BitPCM(float32Array) {\n  const buffer = new ArrayBuffer(float32Array.length * 2);\n  const view = new DataView(buffer);\n  let offset = 0;\n  for (let i = 0; i < float32Array.length; i++, offset += 2) {\n    let s = Math.max(-1, Math.min(1, float32Array[i]));\n    s = s < 0 ? s * 0x8000 : s * 0x7fff;\n    view.setInt16(offset, s, true);\n  }\n  return buffer;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  const chunkSize = 0x8000;\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize);\n    binary += String.fromCharCode.apply(null, chunk);\n  }\n  return btoa(binary);\n}\n\nasync function blobToPcmPayload(audioBlob) {\n  const arrayBuffer = await audioBlob.arrayBuffer();\n  const audioContext = await getAudioContext();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));\n  const channelData = audioBuffer.getChannelData(0);\n  const pcmBuffer = floatTo16BitPCM(channelData);\n  const samplesBase64 = arrayBufferToBase64(pcmBuffer);\n  return {\n    samples: samplesBase64,\n    sampleRate: audioBuffer.sampleRate,\n  };\n}\n\n/**\n * Send audio chunk to backend for processing\n * @param {string} sessionId\n * @param {Blob} audioBlob\n * @returns {Promise<{warning_active: boolean, transcript: object|null}>}\n */\nexport async function sendAudioChunk(sessionId, audioBlob) {\n  const { samples, sampleRate } = await blobToPcmPayload(audioBlob);\n\n  const response = await fetch(`${API_BASE_URL}/api/audio-chunk`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      session_id: sessionId,\n      sample_rate: sampleRate,\n      samples,\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send audio chunk: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Start listening (for monitoring mode)\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function startListening(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/start-listening/${sessionId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to start listening: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Stop listening (for monitoring mode)\n * @param {string} sessionId\n * @returns {Promise<{status: string}>}\n */\nexport async function stopListening(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/stop-listening/${sessionId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to stop listening: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Get session status\n * @param {string} sessionId\n * @returns {Promise<{state: string, transcripts: array}>}\n */\nexport async function getSessionStatus(sessionId) {\n  const response = await fetch(`${API_BASE_URL}/api/session/${sessionId}/status`, {\n    method: 'GET',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to get session status: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}